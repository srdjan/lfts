import {
  AsyncResult,
  match,
  validate,
  validateSafe,
} from "../../packages/lfts-type-runtime/mod.ts";
import type { Result, ValidationError } from "../../packages/lfts-type-runtime/mod.ts";
import { systemClock } from "./ports/clock.ts";
import { denoConsole } from "./ports/console.ts";
import { fileStorage } from "./ports/storage.ts";
import type { LoadError, SaveError } from "./ports/storage.ts";
import { concatenateChunks, decodeText } from "./util.ts";
import type { ClockPort } from "./ports/clock.ts";
import type { ConsolePort } from "./ports/console.ts";
import type { StoragePort } from "./ports/storage.ts";
import type { Task, TaskId } from "./domain/types.ts";
import "./domain/types.schema.ts";
// Consts generated by transformer at build time:
// export const Task$ = [...]; export const TaskList$ = [...]
declare const Task$: any[];
declare const TaskList$: any[];
import type { Command } from "./domain/commands.ts";
import "./domain/commands.schema.ts";
declare const Command$: any[];

/** In-memory store using Record instead of Map (Light-FP style) */
export type Store = Readonly<{ tasks: Readonly<Record<string, Task>> }>;

function createEmptyStore(): Store {
  return { tasks: {} };
}

function newId(clock: ClockPort): TaskId {
  const id = `t_${clock.now()}`;
  return id as TaskId;
}

function toTaskList(store: Store): { tasks: readonly Task[] } {
  return { tasks: Object.values(store.tasks) };
}

function fromTaskList(obj: unknown): Store {
  const list = validate(TaskList$, obj);
  const tasks: Record<string, Task> = {};
  for (const t of list.tasks) {
    tasks[t.id] = t;
  }
  return { tasks };
}

/** Helper to persist store to storage */
async function persistStore(
  store: Store,
  storage: StoragePort,
  io: ConsolePort,
): Promise<void> {
  const json = JSON.stringify(
    validate(TaskList$, toTaskList(store)),
    null,
    2,
  );
  const result = await storage.save(json);
  if (!result.ok) {
    io.log(`Warning: failed to persist tasks to storage: ${result.error}`);
  }
}

/** Helper to load store from storage */
async function loadStore(
  storage: StoragePort,
  io: ConsolePort,
): Promise<Store> {
  const result = await storage.load();
  if (!result.ok) {
    if (result.error === "not_found") {
      return createEmptyStore();
    }
    io.log(`Warning: failed to load tasks: ${result.error}`);
    return createEmptyStore();
  }

  if (result.value === "") {
    return createEmptyStore();
  }

  try {
    return fromTaskList(JSON.parse(result.value));
  } catch (err) {
    io.log(`Warning: failed to parse tasks: ${err instanceof Error ? err.message : String(err)}`);
    return createEmptyStore();
  }
}

export async function handleCommand(
  store: Store,
  clock: ClockPort,
  io: ConsolePort,
  storage: StoragePort,
  cmd: Command,
): Promise<Store> {
  return match(cmd, {
    add: async (c) => {
      const id = newId(clock);
      const t: Task = {
        id,
        name: c.name,
        createdAt: clock.now(),
        completed: false,
      };
      const newStore: Store = {
        tasks: { ...store.tasks, [id]: validate(Task$, t) },
      };
      io.log(`added: ${id} ${t.name}`);

      await persistStore(newStore, storage, io);
      return newStore;
    },
    list: () => {
      const list = Object.values(store.tasks);
      validate(TaskList$, { tasks: list });
      for (const t of list) {
        io.log(`${t.completed ? "✓" : "·"} ${t.id}  ${t.name}`);
      }
      return store;
    },
    complete: async (c) => {
      const t = store.tasks[c.id];
      if (!t) {
        io.log(`not found: ${c.id}`);
        return store;
      }
      const newStore: Store = {
        tasks: { ...store.tasks, [c.id]: { ...t, completed: true } },
      };
      io.log(`completed: ${c.id}`);

      await persistStore(newStore, storage, io);
      return newStore;
    },
    help: () => {
      io.log([
        "Commands:",
        "  add --name <text>",
        "  list",
        "  complete --id <TaskId>",
        "  help",
        "",
        "You can also pipe JSON commands, e.g.:",
        '  echo \'{ "type": "add", "name": "X" }\' | deno task demo',
      ].join("\n"));
      return store;
    },
  });
}

/** Parse CLI args into a Command ADT */
export function parseArgs(args: readonly string[]): Command {
  const [sub, ...rest] = args;
  switch (sub) {
    case "add": {
      const i = rest.indexOf("--name");
      const name = i >= 0 ? rest[i + 1] : undefined;
      if (!name) return { type: "help" };
      return { type: "add", name };
    }
    case "list":
      return { type: "list" };
    case "complete": {
      const i = rest.indexOf("--id");
      const id = i >= 0 ? rest[i + 1] : undefined;
      if (!id) return { type: "help" };
      return { type: "complete", id: id as TaskId };
    }
    case "help":
    default:
      return { type: "help" };
  }
}

async function readJsonFromStdin(
  io: ConsolePort,
): Promise<Command | undefined> {
  try {
    // Read from stdin using modern Deno streams API
    const reader = Deno.stdin.readable.getReader();
    const chunks: Uint8Array[] = [];

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
    }
    reader.releaseLock();

    if (chunks.length === 0) return undefined;

    // Concatenate chunks
    const buf = concatenateChunks(chunks);
    const text = decodeText(buf).trim();
    if (text.length === 0) return undefined;

    const obj = JSON.parse(text);
    const result = validateSafe<Command>(Command$, obj);

    if (!result.ok) {
      io.log(`Invalid command JSON: ${result.error.message}`);
      return undefined;
    }

    return result.value;
  } catch (err) {
    io.log(
      `Failed to parse JSON: ${
        err instanceof Error ? err.message : String(err)
      }`,
    );
    return undefined;
  }
}

// Production entrypoint (uses real ports)
if (import.meta.main) {
  const clock = systemClock();
  const io = denoConsole();
  const storage = fileStorage("./tasks.json");

  // Load persisted state
  let store = await loadStore(storage, io);

  const piped = await readJsonFromStdin(io);
  const cmd = piped ?? parseArgs(Deno.args);
  store = await handleCommand(store, clock, io, storage, cmd);
}
