import { match, validate, validateSafe, type Result, type ValidationError } from "../../packages/lfp-type-runtime/mod.ts";
import { systemClock } from "./src/ports/clock.ts";
import { denoConsole } from "./src/ports/console.ts";
import { fileStorage } from "./src/ports/storage.ts";
import type { ClockPort } from "./src/ports/clock.ts";
import type { ConsolePort } from "./src/ports/console.ts";
import type { StoragePort } from "./src/ports/storage.ts";
import type { Task, TaskId } from "./src/domain/types.ts";
import "./src/domain/types.schema.ts";
// Consts generated by transformer at build time:
// export const Task$ = [...]; export const TaskList$ = [...]
declare const Task$: any[]; declare const TaskList$: any[];
import type { Command } from "./src/domain/commands.ts";
import "./src/domain/commands.schema.ts";
declare const Command$: any[];

/** In-memory store */
export type Store = Readonly<{ tasks: Map<string, Task> }>;

function newId(clock: ClockPort): TaskId {
  const id = `t_${clock.now()}`;
  return id as TaskId;
}

function toTaskList(store: Store): { tasks: readonly Task[] } {
  return { tasks: Array.from(store.tasks.values()) };
}

function fromTaskList(obj: unknown): Store {
  const list = validate(TaskList$, obj);
  const m = new Map<string, Task>();
  for (const t of list.tasks) m.set(t.id, t);
  return { tasks: m };
}

export function handleCommand(store: Store, clock: ClockPort, io: ConsolePort, storage: StoragePort, cmd: Command): Store {
  return match(cmd, {
    add: (c) => {
      const id = newId(clock);
      const t: Task = { id, name: c.name, createdAt: clock.now(), completed: false };
      const next = new Map(store.tasks);
      next.set(id, validate(Task$, t));
      io.log(`added: ${id} ${t.name}`);
      const saved = storage.save(JSON.stringify(validate(TaskList$, toTaskList({ tasks: next })), null, 2));
      if (!saved) {
        io.log("Warning: failed to persist tasks to storage");
      }
      return { tasks: next };
    },
    list: () => {
      const list = Array.from(store.tasks.values());
      validate(TaskList$, { tasks: list });
      for (const t of list) io.log(`${t.completed ? "✓" : "·"} ${t.id}  ${t.name}`);
      return store;
    },
    complete: (c) => {
      const t = store.tasks.get(c.id);
      if (!t) {
        io.log(`not found: ${c.id}`);
        return store;
      }
      const next = new Map(store.tasks);
      next.set(c.id, { ...t, completed: true });
      io.log(`completed: ${c.id}`);
      const saved = storage.save(JSON.stringify(validate(TaskList$, toTaskList({ tasks: next })), null, 2));
      if (!saved) {
        io.log("Warning: failed to persist tasks to storage");
      }
      return { tasks: next };
    },
    help: () => {
      io.log([
        "Commands:",
        "  add --name <text>",
        "  list",
        "  complete --id <TaskId>",
        "  help",
        "",
        "You can also pipe JSON commands, e.g.:",
        '  echo \'{ "type": "add", "name": "X" }\' | deno task demo',
      ].join("\n"));
      return store;
    },
  });
}

/** Parse CLI args into a Command ADT */
export function parseArgs(args: readonly string[]): Command {
  const [sub, ...rest] = args;
  switch (sub) {
    case "add": {
      const i = rest.indexOf("--name");
      const name = i >= 0 ? rest[i + 1] : undefined;
      if (!name) return { type: "help" };
      return { type: "add", name };
    }
    case "list": return { type: "list" };
    case "complete": {
      const i = rest.indexOf("--id");
      const id = i >= 0 ? rest[i + 1] : undefined;
      if (!id) return { type: "help" };
      return { type: "complete", id: id as TaskId };
    }
    case "help":
    default: return { type: "help" };
  }
}

async function readJsonFromStdin(io: ConsolePort): Promise<Command | undefined> {
  try {
    const buf = await Deno.readAll(Deno.stdin);
    const text = new TextDecoder().decode(buf).trim();
    if (text.length === 0) return undefined;

    const obj = JSON.parse(text);
    const result = validateSafe<Command>(Command$, obj);

    if (!result.ok) {
      io.log(`Invalid command JSON: ${result.error.message}`);
      return undefined;
    }

    return result.value;
  } catch (err) {
    io.log(`Failed to parse JSON: ${err instanceof Error ? err.message : String(err)}`);
    return undefined;
  }
}

// Production entrypoint (uses real ports)
if (import.meta.main) {
  const clock = systemClock();
  const io = denoConsole();
  const storage = fileStorage("./tasks.json");

  // Load persisted state
  const loaded = storage.load();
  let store: Store = loaded ? fromTaskList(JSON.parse(loaded)) : { tasks: new Map() };

  const piped = await readJsonFromStdin(io);
  const cmd = piped ?? parseArgs(Deno.args);
  store = handleCommand(store, clock, io, storage, cmd);
}
