// packages/lfts-cli/commands/generate-index.ts
// Generate barrel export index file for schemas

import { walk } from "https://deno.land/std@0.208.0/fs/walk.ts";
import { relative, dirname, basename } from "https://deno.land/std@0.208.0/path/mod.ts";

export interface ExportInfo {
  file: string;
  exports: string[];
}

/**
 * Generate index.schema.ts barrel export file
 */
export async function generateIndexCommand(args: any) {
  const targetDir = args.dir || ".";
  const verbose = args.verbose || false;

  console.log(`Generating index file in: ${targetDir}\n`);

  // Find all .schema.ts files in target directory (not recursive by default)
  const schemaFiles: string[] = [];

  for await (
    const entry of walk(targetDir, {
      maxDepth: 1,
      exts: [".ts"],
      skip: [/node_modules/, /\.git/],
    })
  ) {
    if (
      entry.isFile &&
      entry.path.endsWith(".schema.ts") &&
      !entry.path.endsWith("index.schema.ts")
    ) {
      schemaFiles.push(entry.path);
    }
  }

  if (schemaFiles.length === 0) {
    console.log(`No .schema.ts files found in ${targetDir}`);
    console.log("\nTip: Make sure you're in the correct directory");
    return;
  }

  // Extract exports from each file
  const exports: ExportInfo[] = [];

  for (const file of schemaFiles) {
    const fileExports = await extractExports(file);
    if (fileExports.length > 0) {
      const relPath = relative(targetDir, file);
      exports.push({
        file: relPath,
        exports: fileExports,
      });
    }
  }

  if (exports.length === 0) {
    console.log("No schema exports found");
    return;
  }

  // Generate index.schema.ts content
  const indexContent = generateIndexFile(exports);

  // Write to index.schema.ts
  const indexPath = `${targetDir}/index.schema.ts`;
  await Deno.writeTextFile(indexPath, indexContent);

  console.log(`âœ“ Generated ${indexPath}`);

  // Summary
  const totalExports = exports.reduce((sum, e) => sum + e.exports.length, 0);
  console.log(`  Exported ${totalExports} schema(s) from ${exports.length} file(s)`);

  if (verbose) {
    console.log("\nExported schemas:");
    for (const exp of exports) {
      console.log(`  From ${exp.file}:`);
      for (const name of exp.exports) {
        console.log(`    - ${name}`);
      }
    }
  }

  console.log("\nUsage:");
  console.log(`  import { ${exports[0].exports[0]} } from "${indexPath.replace(/\.ts$/, ".js")}";`);
}

/**
 * Extract export names from a schema file
 */
async function extractExports(file: string): Promise<string[]> {
  const content = await Deno.readTextFile(file);
  const exports: string[] = [];

  // Pattern 1: export const Name$ = ...
  const constPattern = /export\s+const\s+(\w+\$)\s*=/g;
  let match;
  while ((match = constPattern.exec(content)) !== null) {
    exports.push(match[1]);
  }

  // Pattern 2: __schemas metadata object (if present)
  const metaPattern = /export\s+const\s+__schemas\s*=/;
  if (metaPattern.test(content)) {
    exports.push("__schemas");
  }

  return exports;
}

/**
 * Generate index file content
 */
function generateIndexFile(exports: ExportInfo[]): string {
  const lines = [
    "// Auto-generated barrel export for LFTS schemas",
    "// DO NOT EDIT - Generated by: lfts generate-index",
    `// Generated: ${new Date().toISOString()}`,
    "",
  ];

  // Sort exports by file name for consistency
  const sortedExports = [...exports].sort((a, b) =>
    a.file.localeCompare(b.file)
  );

  for (const exp of sortedExports) {
    // Convert .ts to .js for import path
    const importPath = "./" + exp.file.replace(/\.ts$/, ".js");

    // Create export statement
    if (exp.exports.length === 1) {
      lines.push(`export { ${exp.exports[0]} } from "${importPath}";`);
    } else if (exp.exports.length > 1) {
      const exportList = exp.exports.join(", ");
      lines.push(`export {`);
      for (const name of exp.exports) {
        lines.push(`  ${name},`);
      }
      lines.push(`} from "${importPath}";`);
    }
  }

  lines.push(""); // Trailing newline
  return lines.join("\n");
}
