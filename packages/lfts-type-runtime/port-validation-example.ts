// packages/lfts-type-runtime/port-validation-example.ts
//
// Port Validation Examples: Runtime Contract Verification
//
// This file demonstrates how to use validatePort() for runtime validation
// of port/capability implementations in LFTS applications.

import { enc } from "../lfts-type-spec/src/mod.ts";
import {
  AsyncResult,
  getPortMethods,
  getPortName,
  Result,
  validatePort,
} from "./mod.ts";

// ============================================================================
// Example 1: Basic Port Validation
// ============================================================================

console.log("=== Example 1: Basic Port Validation ===\n");

// Define a port interface (this would normally be in a .ts file)
interface LoggerPort {
  log(message: string): void;
  error(message: string): void;
  warn(message: string): void;
}

// Create port bytecode schema (normally generated by compiler)
const LoggerPort$ = enc.port("LoggerPort", [
  { name: "log", params: [enc.str()], returnType: enc.und() },
  { name: "error", params: [enc.str()], returnType: enc.und() },
  { name: "warn", params: [enc.str()], returnType: enc.und() },
]);

// Valid implementation
const consoleLogger: LoggerPort = {
  log: (msg) => console.log(`[LOG] ${msg}`),
  error: (msg) => console.error(`[ERROR] ${msg}`),
  warn: (msg) => console.warn(`[WARN] ${msg}`),
};

const result1 = validatePort<LoggerPort>(LoggerPort$, consoleLogger);
if (result1.ok) {
  console.log("✓ Console logger is valid");
  result1.value.log("This works!");
} else {
  console.log("✗ Validation failed:", result1.error.message);
}

// Invalid implementation (missing method)
const brokenLogger = {
  log: (msg: string) => console.log(msg),
  // missing 'error' and 'warn'
};

const result2 = validatePort<LoggerPort>(LoggerPort$, brokenLogger);
if (!result2.ok) {
  console.log("✗ Broken logger rejected:", result2.error.message);
}

console.log();

// ============================================================================
// Example 2: Dependency Injection with Validation
// ============================================================================

console.log("=== Example 2: Dependency Injection ===\n");

interface StoragePort {
  load(key: string): Promise<Result<string, string>>;
  save(key: string, value: string): Promise<Result<void, string>>;
}

const StoragePort$ = enc.port("StoragePort", [
  { name: "load", params: [enc.str()], returnType: enc.obj([]) },
  { name: "save", params: [enc.str(), enc.str()], returnType: enc.obj([]) },
]);

// In-memory storage implementation
const memoryStorage: StoragePort = {
  async load(key) {
    const data = new Map<string, string>();
    const value = data.get(key);
    return value ? Result.ok(value) : Result.err("not_found");
  },
  async save(key, value) {
    const data = new Map<string, string>();
    data.set(key, value);
    return Result.ok(undefined);
  },
};

// Dependency injection container
class Container {
  private ports = new Map<string, any>();

  register<T>(portSchema: any, impl: unknown): Result<void, string> {
    const portName = getPortName(portSchema);
    if (!portName) {
      return Result.err("Invalid port schema");
    }

    const validation = validatePort<T>(portSchema, impl);
    if (!validation.ok) {
      return Result.err(
        `Failed to register ${portName}: ${validation.error.message}`,
      );
    }

    this.ports.set(portName, validation.value);
    return Result.ok(undefined);
  }

  get<T>(portName: string): T | undefined {
    return this.ports.get(portName);
  }
}

const container = new Container();

// Register storage port
const registerResult = container.register<StoragePort>(
  StoragePort$,
  memoryStorage,
);
if (registerResult.ok) {
  console.log("✓ StoragePort registered successfully");

  const storage = container.get<StoragePort>("StoragePort");
  if (storage) {
    console.log("✓ Retrieved storage from container");
  }
} else {
  console.log("✗ Registration failed:", registerResult.error);
}

console.log();

// ============================================================================
// Example 3: Plugin System with Runtime Validation
// ============================================================================

console.log("=== Example 3: Plugin System ===\n");

interface PluginPort {
  name(): string;
  version(): string;
  initialize(): Promise<Result<void, string>>;
  execute(input: any): Promise<Result<any, string>>;
}

const PluginPort$ = enc.port("PluginPort", [
  { name: "name", params: [], returnType: enc.str() },
  { name: "version", params: [], returnType: enc.str() },
  { name: "initialize", params: [], returnType: enc.obj([]) },
  { name: "execute", params: [enc.obj([])], returnType: enc.obj([]) },
]);

class PluginManager {
  private plugins = new Map<string, PluginPort>();

  async loadPlugin(plugin: unknown): Promise<Result<string, string>> {
    // Validate plugin structure
    const validation = validatePort<PluginPort>(PluginPort$, plugin);
    if (!validation.ok) {
      return Result.err(
        `Invalid plugin: ${validation.error.message}`,
      );
    }

    const validPlugin = validation.value;

    // Initialize plugin
    const initResult = await validPlugin.initialize();
    if (!initResult.ok) {
      return Result.err(
        `Plugin initialization failed: ${initResult.error}`,
      );
    }

    // Register plugin
    const pluginName = validPlugin.name();
    this.plugins.set(pluginName, validPlugin);

    return Result.ok(pluginName);
  }

  getPlugin(name: string): PluginPort | undefined {
    return this.plugins.get(name);
  }

  listPlugins(): string[] {
    return Array.from(this.plugins.keys());
  }
}

// Example plugin implementation
const dataTransformPlugin: PluginPort = {
  name: () => "data-transform",
  version: () => "1.0.0",
  initialize: async () => Result.ok(undefined),
  execute: async (input) => Result.ok({ transformed: input }),
};

const pluginManager = new PluginManager();
const loadResult = await pluginManager.loadPlugin(dataTransformPlugin);

if (loadResult.ok) {
  console.log(`✓ Plugin loaded: ${loadResult.value}`);
  console.log(`✓ Active plugins: ${pluginManager.listPlugins().join(", ")}`);
} else {
  console.log(`✗ Plugin load failed: ${loadResult.error}`);
}

console.log();

// ============================================================================
// Example 4: Port Introspection
// ============================================================================

console.log("=== Example 4: Port Introspection ===\n");

interface DatabasePort {
  connect(): Promise<Result<void, string>>;
  query(sql: string, params: any[]): Promise<Result<any[], string>>;
  execute(sql: string, params: any[]): Promise<Result<number, string>>;
  disconnect(): Promise<Result<void, string>>;
}

const DatabasePort$ = enc.port("DatabasePort", [
  { name: "connect", params: [], returnType: enc.obj([]) },
  { name: "query", params: [enc.str(), enc.arr(enc.obj([]))], returnType: enc.obj([]) },
  { name: "execute", params: [enc.str(), enc.arr(enc.obj([]))], returnType: enc.obj([]) },
  { name: "disconnect", params: [], returnType: enc.obj([]) },
]);

// Introspect port schema
const portName = getPortName(DatabasePort$);
const methods = getPortMethods(DatabasePort$);

console.log(`Port name: ${portName}`);
console.log(`Methods: ${methods.join(", ")}`);
console.log(`Method count: ${methods.length}`);

console.log();

// ============================================================================
// Example 5: AsyncResult Integration
// ============================================================================

console.log("=== Example 5: AsyncResult Integration ===\n");

// Helper to load and validate a port asynchronously
async function loadPort<T>(
  portSchema: any,
  impl: unknown,
): Promise<Result<T, string>> {
  return AsyncResult.try(
    async () => {
      const portName = getPortName(portSchema) || "Unknown";
      console.log(`Loading port: ${portName}...`);

      // Simulate async loading delay
      await new Promise((resolve) => setTimeout(resolve, 10));

      const result = validatePort<T>(portSchema, impl);
      if (!result.ok) {
        throw new Error(result.error.message);
      }

      console.log(`✓ Port ${portName} validated`);
      return result.value;
    },
    (err) => `Port loading failed: ${(err as Error).message}`,
  );
}

// Load multiple ports in parallel
const loadResults = await AsyncResult.all([
  loadPort<LoggerPort>(LoggerPort$, consoleLogger),
  loadPort<StoragePort>(StoragePort$, memoryStorage),
  loadPort<PluginPort>(PluginPort$, dataTransformPlugin),
]);

if (loadResults.ok) {
  console.log(`✓ All ${loadResults.value.length} ports loaded successfully`);
} else {
  console.log(`✗ Port loading failed: ${loadResults.error}`);
}

console.log();

// ============================================================================
// Example 6: Testing Port Implementations
// ============================================================================

console.log("=== Example 6: Testing Framework ===\n");

// Test harness for port implementations
class PortTester {
  static test<T>(
    portSchema: any,
    impl: unknown,
    testName: string,
  ): void {
    const portName = getPortName(portSchema) || "Unknown";
    const result = validatePort<T>(portSchema, impl);

    if (result.ok) {
      console.log(`✓ ${testName}: ${portName} passes validation`);
    } else {
      console.log(`✗ ${testName}: ${result.error.message}`);
    }
  }
}

// Test various implementations
PortTester.test(LoggerPort$, consoleLogger, "Console Logger");
PortTester.test(LoggerPort$, brokenLogger, "Broken Logger (expected fail)");
PortTester.test(StoragePort$, memoryStorage, "Memory Storage");
PortTester.test(
  StoragePort$,
  { load: "not a function" },
  "Invalid Storage (expected fail)",
);

console.log();

// ============================================================================
// Example 7: Port Adapter Pattern
// ============================================================================

console.log("=== Example 7: Port Adapter Pattern ===\n");

// Create an adapter that validates and wraps port implementations
function createPortAdapter<T>(
  portSchema: any,
  impl: unknown,
): Result<T, string> {
  const validation = validatePort<T>(portSchema, impl);

  if (!validation.ok) {
    return Result.err(
      `Port validation failed: ${validation.error.message}`,
    );
  }

  // Could add additional wrapping logic here (logging, metrics, etc.)
  return Result.ok(validation.value);
}

const loggerAdapter = createPortAdapter<LoggerPort>(
  LoggerPort$,
  consoleLogger,
);

if (loggerAdapter.ok) {
  console.log("✓ Logger adapter created successfully");
  loggerAdapter.value.log("Adapter works!");
} else {
  console.log(`✗ Adapter creation failed: ${loggerAdapter.error}`);
}

console.log();

// ============================================================================
// Example 8: Configuration-Driven Port Selection
// ============================================================================

console.log("=== Example 8: Configuration-Driven Selection ===\n");

type StorageConfig = {
  type: "memory" | "file" | "database";
  options?: Record<string, unknown>;
};

function createStorage(
  config: StorageConfig,
): Result<StoragePort, string> {
  let impl: unknown;

  switch (config.type) {
    case "memory":
      impl = memoryStorage;
      break;
    case "file":
      impl = {
        load: async (key: string) => Result.ok(`file data for ${key}`),
        save: async (key: string, value: string) => Result.ok(undefined),
      };
      break;
    case "database":
      impl = {
        load: async (key: string) => Result.ok(`db data for ${key}`),
        save: async (key: string, value: string) => Result.ok(undefined),
      };
      break;
    default:
      return Result.err(`Unknown storage type: ${config.type}`);
  }

  // Validate implementation matches port contract
  const validation = validatePort<StoragePort>(StoragePort$, impl);
  if (!validation.ok) {
    return Result.err(
      `${config.type} storage implementation is invalid: ${validation.error.message}`,
    );
  }

  console.log(`✓ Created ${config.type} storage`);
  return Result.ok(validation.value);
}

const storage1 = createStorage({ type: "memory" });
const storage2 = createStorage({ type: "file" });
const storage3 = createStorage({ type: "database" });

console.log(
  `✓ All storage adapters validated: ${[storage1, storage2, storage3].filter((s) => s.ok).length}/3`,
);

console.log("\n✅ All port validation examples completed!");
