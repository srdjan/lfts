# LFTS Type Runtime

Light-FP TypeScript runtime validator with bytecode-based validation.

## Overview

The LFTS runtime provides high-performance validation of values against bytecode schemas generated by the LFTS compiler. It's designed to be minimal, explicit, and tree-shakeable.

## Core Features

- **Bytecode validation** - Fast validation against compiler-generated bytecode
- **Result types** - Functional error handling with `Result<T, E>`
- **Pattern matching** - Exhaustive ADT matching with `match()`
- **Introspection** - Runtime schema examination via `introspect()`
- **Port validation helpers** - `validatePort()`, `getPortName()`, `getPortMethods()` keep ports/capabilities honest

## Simplicity Charter

The LFTS runtime follows strict principles to maintain simplicity and predictability:

### 1. Core Primitives vs Optional Helpers

**Core (always included):**
- Validation functions: `validate()`, `validateAll()`
- Result types: `Result<T, E>`, `Option<T>`, `ValidationResult<T>`
- Pattern matching: `match()`
- Introspection: `introspect()`, `getKind()`, `getProperties()`, etc.
- Port helpers: `getPortName()`, `getPortMethods()`

**Optional helpers (separate modules):**
- **Pipeline** (`./pipeline.ts`) - Optional async pipeline composition (not exported by `mod.ts`)
  - Repo-root import: `import { pipe, asPipe, PipelineExecutionError } from "./packages/lfts-type-runtime/pipeline.ts"`
  - Local import (inside this package): `import { pipe, asPipe, PipelineExecutionError } from "./pipeline.ts"`
  - `.run()` throws `PipelineExecutionError` on `Result.err`, `.runResult()` stays exception-free
  - Not included in bundles unless used (tree-shaking)

**Breaking note (v0.9.0):** Pipeline helpers were removed from `mod.ts` exports.
Update any `mod.ts` imports to the explicit subpath before upgrading.

**AsyncResult** - Coming soon as separate module
  - Async effect composition helpers
  - Will follow same pattern as Pipeline

### 2. Direct-Style Programming

**We favor:** Plain functions and direct composition

```typescript
// ✅ Direct style - clear and composable
const result = validate(UserSchema, data);
if (!result.ok) {
  return Result.err(result.errors);
}
const user = result.value;

// ✅ Direct composition
const validated = validate(schema, data);
const transformed = validated.ok
  ? transform(validated.value)
  : validated;
```

**We avoid:** Monadic instance methods and method chaining

```typescript
// ❌ Monadic style - not supported
result.map(x => x + 1)
      .flatMap(doSomething)
      .orElse(handleError)
```

**Rationale:** Direct style is more explicit, easier to debug, and doesn't require learning monad laws.

### 3. Minimal Combinator Surface

**We provide:** Essential composition primitives

- `Result.ok()`, `Result.err()` - Construct results
- `match()` - Exhaustive pattern matching for ADTs
- Basic helpers for common patterns

**We avoid:** Typeclass-style combinators

- ❌ `ap()` - Applicative apply
- ❌ `liftN()` - Lift N-ary functions
- ❌ `traverse()` - Effect sequencing
- ❌ `sequence()` - Sequence collections of effects

**Rationale:** These combinators add complexity without sufficient value for Light-FP use cases. Applications can implement domain-specific helpers as needed.

### 4. Ports Pattern Discipline

**Effects live at application edges:**

```typescript
// ✅ Ports define interfaces (no implementations)
interface StoragePort {
  load(id: string): Promise<Data>;
  save(data: Data): Promise<void>;
}

// ✅ Concrete implementations at edges
const storage: StoragePort = {
  load: async (id) => {
    const data = await Deno.readTextFile(`data/${id}.json`);
    return JSON.parse(data);
  },
  save: async (data) => {
    await Deno.writeTextFile(`data/${data.id}.json`, JSON.stringify(data));
  },
};
```

**Keep Deno.* and concrete effects out of library code:**

```typescript
// ❌ Concrete effects in library
export async function loadUser(id: string) {
  const data = await Deno.readTextFile(`users/${id}.json`); // ❌
  return JSON.parse(data);
}

// ✅ Port-based design
export async function loadUser(
  id: string,
  storage: StoragePort // ✅ Dependency injection
) {
  return await storage.load(id);
}
```

**Rationale:** This keeps library code pure, testable, and platform-agnostic.

### 5. Favor Composable Primitives Over Frameworks

**Build domain-specific helpers from primitives:**

```typescript
// ✅ Domain-specific composition
async function withRetry<T>(
  fn: () => Promise<Result<T, Error>>,
  attempts: number
): Promise<Result<T, Error>> {
  for (let i = 0; i < attempts; i++) {
    const result = await fn();
    if (result.ok) return result;
  }
  return Result.err(new Error("Max retries exceeded"));
}

// Use in application
const result = await withRetry(
  () => fetchData(storage),
  3
);
```

**Rather than:**

```typescript
// ❌ Generic framework with many abstractions
const pipeline = new RetryPipeline({ attempts: 3 })
  .addMiddleware(loggingMiddleware)
  .addMiddleware(metricsMiddleware)
  .execute(fetchData);
```

**Rationale:** Composable primitives are easier to understand, customize, and maintain than layered frameworks.

## Usage

### Basic Validation

```typescript
import { validate, Result } from "./mod.ts";

const UserSchema = [/* bytecode from compiler */];

const result = validate(UserSchema, data);

if (!result.ok) {
  console.error("Validation failed:", result.errors);
  return;
}

const user = result.value;
console.log("Valid user:", user);
```

### Aggregate Errors

```typescript
import { validateAll } from "./mod.ts";

const result = validateAll(UserSchema, data, { maxErrors: 10 });

if (!result.ok) {
  for (const error of result.errors) {
    console.error(`${error.path}: ${error.message}`);
  }
}
```

### Pattern Matching

```typescript
import { match } from "./mod.ts";

type Result =
  | { type: "success"; value: number }
  | { type: "error"; message: string };

const result: Result = { type: "success", value: 42 };

const output = match(result, {
  success: (r) => `Got value: ${r.value}`,
  error: (r) => `Error: ${r.message}`,
});
```

### Introspection

```typescript
import { introspect } from "./introspection.ts";

const schema = UserSchema;
const info = introspect(schema);

console.log("Schema kind:", info.kind);
if (info.kind === "object") {
  console.log("Properties:", info.properties.map(p => p.name));
}
```

### Optional Pipeline (Experimental)

```typescript
import { pipe, asPipe, PipelineExecutionError } from "./pipeline.ts";

const upper = asPipe((s: string) => s.toUpperCase());
const exclaim = asPipe((s: string) => s + "!");

const greeting = pipe("hello");
// @ts-expect-error bitwise pipeline shim
greeting | upper | exclaim;

const result = await greeting.run();
console.log(result); // "HELLO!"
```

**Note:** Pipeline is experimental and may change. Use at your own risk.

### Workflow Graph Builder (Experimental)

```typescript
import { graphBuilder, fromStage, fromStages } from "./workflow-graph.ts";
import type { WorkflowStep } from "./workflow.ts";

const workflow = graphBuilder<{ userId: string }>()
  .seed({ userId: "usr_123" })
  .stage({ name: "fetchUser", step: fetchUserStep })
  .stage({
    name: "loadPermissions",
    step: loadPermissionsStep,
    dependsOn: ["fetchUser"],
    resolve: fromStage<{ userId: string }, { userId: string }>(
      "fetchUser",
      (output) => ({ userId: output.userId }),
    ),
  })
  .stage({
    name: "hydrateProfile",
    step: hydrateProfileStep,
    dependsOn: ["fetchUser", "loadPermissions"],
    resolve: fromStages(
      ["fetchUser", "loadPermissions"],
      (values) => ({
        user: values.fetchUser,
        permissions: values.loadPermissions,
      }),
    ),
  })
  .build();

const result = await workflow.run();
if (result.ok) {
  console.log(result.value.outputs.hydrateProfile);
}
```

- DAG-driven scheduling inferred from dependencies
- Seeds accept values, promises, or `Result`
- Optional `resolve()` hook per stage to map dependency outputs into typed inputs
- Helper utilities `fromStage()` / `fromStages()` remove boilerplate when wiring dependencies
- Snapshots capture per-stage timing/status for observability

## Performance

The LFTS runtime is optimized for high-performance validation:

- **DUNION tag caching:** 40x-1,600x speedup for ADT validation
- **Lazy path construction:** Build error paths only on failure
- **Result-based unions:** 2-5x faster than exception-based
- **WeakMap caching:** O(1) tag lookup after first validation

See [../../docs/BYTECODE_REFERENCE.md](../../docs/BYTECODE_REFERENCE.md) for benchmarks.

## Tree-Shaking

The runtime is designed for optimal tree-shaking:

- **Core validation:** Always included (~8KB minified)
- **Introspection:** Only if you use `introspect()` (~2KB)
- **Pipeline:** Only if you import from `./pipeline.ts` (~3KB)
- **Workflow graph builder:** Only if you import from `./workflow-graph.ts` (~4KB)
- **Port helpers:** Only if you use `getPortName()` etc. (~1KB)

**Example bundle sizes:**
- Validation only: ~8KB
- Validation + introspection: ~10KB
- Validation + Pipeline: ~11KB
- Validation + Workflow Graphs: ~12KB
- Everything: ~14KB

## Architecture

### Module Structure

```
packages/lfts-type-runtime/
├── mod.ts              # Core validation and types
├── introspection.ts    # Schema introspection
├── pipeline.ts         # Optional async pipeline (experimental)
├── workflow-graph.ts   # Workflow DAG builder (experimental)
├── async-result.ts     # (Coming soon) Async effect helpers
└── README.md           # This file
```

### Design Principles

1. **Explicit over implicit** - No magic, clear transformations
2. **Minimal runtime surface** - Small API, focused features
3. **Direct-style programming** - Plain functions, not monads
4. **Composable primitives** - Build helpers from basics
5. **Tree-shakeable** - Pay only for what you use

## Contributing

When adding features to the runtime, follow the Simplicity Charter:

1. **Question abstractions** - Is this feature essential?
2. **Prefer primitives** - Can users build this from existing APIs?
3. **Consider bundle size** - Can this be a separate module?
4. **Maintain direct style** - Avoid monadic patterns
5. **Document boundaries** - Make optional vs core explicit

## License

MIT

## See Also

- [BYTECODE_REFERENCE.md](../../docs/BYTECODE_REFERENCE.md) - Bytecode format and opcodes
- [EFFECTS_GUIDE.md](../../docs/EFFECTS_GUIDE.md) - Effect handling patterns
- [FUTURE_DIRECTION.md](../../docs/FUTURE_DIRECTION.md) - Planned features and principles
