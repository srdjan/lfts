# LFTS CLI

Command-line tools for the Light-FP TypeScript runtime.

## Installation

The LFTS CLI is included in the LFTS repository and can be run via deno tasks:

```bash
# Run CLI directly
deno task lfts <command> [options]

# Or use command-specific shortcuts
deno task lfts:list      # List all schemas
deno task lfts:find      # Find schemas
deno task lfts:index     # Generate index files
```

## Commands

### list-schemas

Scans the project and lists all LFTS schemas organized by directory.

**Usage:**
```bash
deno task lfts:list [--verbose]
```

**Options:**
- `--verbose, -v` - Show detailed output

**Example:**
```bash
$ deno task lfts:list

Scanning for LFTS schemas...

examples/01-hello-world/src/
  types.schema.ts:
    - User$

packages/lfts-type-runtime/
  mod.schema.ts:
    - ValidationError$

Found 2 schema(s) in 2 file(s)
```

**What it finds:**
- Pattern 1: `export const Name$ = typeOf<T>()` (explicit pattern)
- Pattern 2: `export type NameSchema = T` (schema-root pattern, generates `Name$` at compile time)

### find-schema

Searches for a specific schema by name with fuzzy matching.

**Usage:**
```bash
deno task lfts:find <name>
```

**Arguments:**
- `<name>` - Schema name to search for (supports fuzzy matching)

**Example:**
```bash
$ deno task lfts:find User

Searching for schemas matching "User"...

Found 2 match(es):

  User$
    File: examples/01-hello-world/src/types.schema.ts
    Source: User
    Import: import { User$ } from "./examples/01-hello-world/src/types.schema.js";

    Usage:
      import { User$ } from "./examples/01-hello-world/src/types.schema.js";
      import { validate } from "lfts-type-runtime";

      const result = validate(User$, data);

  UserProfile$
    File: src/domain/user.schema.ts
    Import: import { UserProfile$ } from "./src/domain/user.schema.js";
```

**Scoring:**
- Exact match: 100 points (highest priority)
- Starts with: 80 points
- Contains: 60 points
- Fuzzy match: 40-60 points
- No match: 0 points

### generate-index

Generates a barrel export file (`index.schema.ts`) for all schemas in a directory.

**Usage:**
```bash
deno task lfts:index [--dir <path>] [--verbose]
```

**Options:**
- `--dir <path>` - Target directory (defaults to current directory)
- `--verbose, -v` - Show detailed output with all exported schemas

**Example:**
```bash
$ deno task lfts:index --dir src/domain

Generating index file in: src/domain

✓ Generated src/domain/index.schema.ts
  Exported 5 schema(s) from 3 file(s)

Usage:
  import { User$ } from "src/domain/index.schema.js";
```

**Generated file format:**
```typescript
// Auto-generated barrel export for LFTS schemas
// DO NOT EDIT - Generated by: lfts generate-index
// Generated: 2025-11-01T22:27:16.178Z

export { User$ } from "./user.schema.js";
export { Product$, Category$ } from "./catalog.schema.js";
export { Order$, OrderItem$ } from "./order.schema.js";
```

**Important notes:**
- Only scans the target directory (non-recursive by default)
- Skips existing `index.schema.ts` files
- Converts `.ts` extensions to `.js` for import paths (ESM convention)
- Works on **source files** with explicit pattern (`export const Name$ = typeOf<T>()`)
- For schema-root pattern, run after compilation or use explicit pattern in schemas

### help

Shows CLI usage information.

**Usage:**
```bash
deno task lfts help
```

## Common Workflows

### Discovering Schemas in a New Project

```bash
# 1. List all schemas to understand project structure
deno task lfts:list

# 2. Find a specific schema for integration
deno task lfts:find User

# 3. Copy the import statement and use in your code
import { User$ } from "./path/to/user.schema.js";
import { validate } from "lfts-type-runtime";

const result = validate(User$, data);
```

### Creating Barrel Exports

```bash
# Generate index for domain layer
deno task lfts:index --dir src/domain

# Generate index for API schemas
deno task lfts:index --dir src/api/schemas

# Now you can import from index files
import { User$, Product$, Order$ } from "./src/domain/index.schema.js";
```

### Searching Across Large Codebases

```bash
# Find all User-related schemas
deno task lfts:find User

# Find schemas with verbose output
deno task lfts:list --verbose
```

## Schema Patterns

The CLI recognizes two schema definition patterns:

### Pattern 1: Explicit (Recommended for CLI tools)

```typescript
// user.schema.ts
import { typeOf } from "lfts-type-runtime";
import type { User } from "./user.ts";

export const User$ = typeOf<User>();
```

**CLI support:**
- ✅ `list-schemas` finds it
- ✅ `find-schema` finds it
- ✅ `generate-index` includes it

### Pattern 2: Schema-Root (Zero-exposure)

```typescript
// user.schema.ts
import type { User } from "./user.ts";

export type UserSchema = User;
// Compiler generates: export const User$ = [bytecode]
```

**CLI support:**
- ✅ `list-schemas` finds `UserSchema` type in source
- ✅ `find-schema` finds it by source name
- ⚠️ `generate-index` requires compilation first (works on compiled output)

**Recommendation:** Use Pattern 1 (explicit) in files where you want barrel exports, or run `generate-index` on compiled output directories.

## Tips

### Performance

All CLI commands are designed for fast execution:
- Efficient directory traversal with skip patterns (`node_modules`, `.git`, `dist`)
- Regex-based parsing (no AST parsing overhead)
- Minimal dependencies (Deno std library only)

### Integration

The CLI is just a wrapper around your schemas - it doesn't modify anything:
- `list-schemas` and `find-schema` are read-only
- `generate-index` only creates new files, never modifies existing schemas
- All commands respect `.gitignore` patterns (skips `node_modules`, `dist`, etc.)

### Barrel Export Best Practices

1. **Generate per-layer:** Create separate index files for each architectural layer
   ```bash
   deno task lfts:index --dir src/domain
   deno task lfts:index --dir src/api
   ```

2. **Commit generated files:** Treat `index.schema.ts` as source code, not build artifacts

3. **Regenerate on schema changes:** Add to your workflow:
   ```bash
   # After adding new schemas
   deno task lfts:index --dir src/domain
   git add src/domain/index.schema.ts
   git commit -m "Add new schemas"
   ```

4. **Use for public APIs:** Generate indexes for exported packages/modules

## Troubleshooting

### "No .schema.ts files found"

**Problem:** CLI doesn't find any schema files.

**Solutions:**
- Ensure you're in the project root
- Check that files end with `.schema.ts`
- Use `--verbose` to see what's being scanned
- Verify files aren't in excluded directories (`node_modules`, `.git`, `dist`)

### "No schema exports found"

**Problem:** `generate-index` finds files but no exports.

**Solutions:**
- Ensure schemas use the explicit pattern: `export const Name$ = typeOf<T>()`
- If using schema-root pattern, run on compiled output directory
- Check that exports aren't commented out

### "Module not found" when importing generated index

**Problem:** Import from `index.schema.js` fails.

**Solutions:**
- Ensure you're importing the `.js` extension (ESM convention)
- Check the import path is relative or absolute as needed
- Verify the index file was generated in the expected location

## Version History

- **v0.8.0** - Initial CLI release
  - Added `list-schemas` command
  - Added `find-schema` command with fuzzy matching
  - Added `generate-index` command for barrel exports

## Future Enhancements

Planned CLI features (Priority 2-3):

- `lfts validate <file> <schema>` - Validate JSON/YAML files against schemas
- `lfts codegen mock <schema>` - Generate mock data from schemas
- `lfts codegen json-schema <schema>` - Generate JSON Schema from LFTS schema
- `lfts codegen typescript <schema>` - Generate TypeScript types from schema bytecode
- Watch mode for `generate-index` with auto-regeneration
- Config file support for custom scan directories and patterns

See [PHASE3_PLAN.md](PHASE3_PLAN.md) for complete implementation roadmap.
