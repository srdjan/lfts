# Building a Light-FP Program from Scratch

Light-FP (LFP) is a TypeScript compiler mode designed for teams that love functional programming but still want runtime safety at the edges. It enforces a small, opinionated subset of TypeScript, compiles `typeOf<T>()` calls into Deepkit-compatible bytecode, and ships a runtime that validates data using that bytecode. In this tutorial we will build an LFP app from scratch, walk through the compilation pipeline, inspect the generated bytecode, and finish by exercising the runtime validators. All examples below are reproducible with Deno 1.45+.

## Introduction: Why Light-FP?

LFP is centered on three principles:

- Canonical functional TypeScript: only type aliases for data, readonly-by-default values, algebraic data types (ADTs) tagged with a type discriminant, and no classes or `this`.
- Compile-time enforcement: a gate pass bans unsupported syntax, a policy pass applies semantic rules (for example, “no `T | undefined` in schemas”), and a transform pass rewrites `typeOf<T>()` into bytecode literals.
- Runtime confidence: validators walk the bytecode (arrays of opcodes such as `Op.OBJECT`, `Op.PROPERTY`, `Op.DUNION`) to provide precise error messages with path information without shipping the original TypeScript types.

Throughout this tutorial we mirror the patterns already used in `demo_cli` and `deno_example` inside the repository.

## Project Setup

### Create the workspace

Create a folder and drop in the minimal configuration:

```sh
mkdir lfp-blog-demo
cd lfp-blog-demo
```

### Configure Deno tasks

`deno.json` wires convenient tasks and sticks to ES2022:

```json
{
  "tasks": {
    "build": "deno run -A packages/lfp-type-compiler/src/cli.ts src --outDir dist",
    "start": "deno run -A dist/main.js"
  },
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "strict": true
  }
}
```

### Configure LFP rules

`lfp.config.json` controls policy flags. Enable every default rule:

```json
{
  "rules": {
    "LFP1006": true,
    "LFP1007": true,
    "LFP1008": true,
    "LFP1009": true,
    "LFP1010": true,
    "LFP1011": true,
    "LFP1014": true,
    "LFP1015": true,
    "LFP1016": true
  }
}
```

### Add compiler and runtime packages

Add the runtime and compiler packages as Git submodules or copy them into `packages/`, matching the repository layout:

```
packages/
  lfp-type-compiler/...
  lfp-type-runtime/...
  lfp-type-spec/...
```

For brevity we assume these packages are already in place.

### Expected tree

Your initial tree should look like:

```
.
├─ deno.json
├─ lfp.config.json
├─ packages/
│  ├─ lfp-type-compiler/
│  ├─ lfp-type-runtime/
│  └─ lfp-type-spec/
└─ src/
```

## Domain Modeling the LFP Way

### 1. Domain Types (`src/types.ts`)

We will build a tiny Task app similar to `demo_cli` but pared down for clarity.

```ts
// src/types.ts
export type TaskId = string & { readonly __brand: "TaskId" };

export type Task = Readonly<{
  readonly id: TaskId;
  readonly name: string;
  readonly createdAt: number;
  readonly completed: boolean;
  readonly owner?: User["id"];
}>;

export type User = Readonly<{
  readonly id: UserId;
  readonly name: string;
  readonly email?: string;
}>;

export type UserId = string & { readonly __brand: "UserId" };

export type TaskEvent =
  | { readonly type: "created"; readonly task: Task }
  | { readonly type: "completed"; readonly taskId: TaskId; readonly at: number }
  | { readonly type: "deleted"; readonly taskId: TaskId };
```

#### Highlights

- Data uses `type`, not `interface` (policy rule LFP1008 would reject interfaces).
- Brands are structural intersections with a readonly `__brand` property; the encoder recognizes this pattern and emits `Op.BRAND`.
- Optional fields use the `?` suffix (`email?`, `owner?`) rather than `T | undefined` (LFP1009).
- ADTs share a type discriminant so the policy pass can enforce LFP1006 and the encoder can emit `Op.DUNION`.

### 2. Schema Roots (`src/types.schema.ts`)

Schema files export type aliases suffixed with `Schema`. The schema-root rewriter turns them into bytecode constants.

```ts
// src/types.schema.ts
import type { Task, TaskEvent, User } from "./types.ts";

export type TaskSchema = Task;
export type UserSchema = User;
export type TaskEventSchema = TaskEvent;
```

Rule LFP1016 forbids `typeOf<T>()` and schema aliases outside `*.schema.ts`, keeping domain modules free of compiler glue.

### 3. Application Entry (`src/main.ts`)

We will read JSON from disk, validate it, and use pattern matching.

```ts
// src/main.ts
import { match, serialize, validate } from "../packages/lfp-type-runtime/mod.ts";
import "./types.schema.ts";
// schema-root rewriter will emit Task$, User$, TaskEvent$
declare const TaskSchema$: any[];
declare const UserSchema$: any[];
declare const TaskEventSchema$: any[];

const raw = await Deno.readTextFile("./sample.json");
const parsed = JSON.parse(raw);

const task = validate(TaskSchema$, parsed);

console.log("Validated task", task);

const event = match<Parameters<typeof makeEvent>[0], string>( // illustrate match helper
  { type: "completed", taskId: task.id, at: Date.now() },
  {
    created: ({ task }) => `Created ${task.name}`,
    completed: ({ taskId }) => `Completed ${taskId}`,
    deleted: ({ taskId }) => `Deleted ${taskId}`
  }
);

console.log("Event summary", event);

// Example serializer usage (just validates and returns value)
function makeEvent(evt: import("./types.ts").TaskEvent) {
  return serialize(TaskEventSchema$, evt);
}
```

## Project Structure Recap

```
src/
  main.ts
  types.ts
  types.schema.ts
packages/
  lfp-type-compiler/
  lfp-type-runtime/
  lfp-type-spec/
deno.json
lfp.config.json
```

## Compilation with `deno task build`

Running the build task kicks off the compiler CLI:

```text
$ deno task build
Task build deno run -A packages/lfp-type-compiler/src/cli.ts src --outDir dist
✨  Gate pass (syntax bans) – 0 diagnostics
✨  Policy pass (semantic rules) – 0 diagnostics
✨  Transform pass – emitted bytecode for 3 schemas
```

Let’s unpack each stage.

### 1. Gate Pass

`packages/lfp-type-compiler/src/gate/gate.ts` bans syntax that breaks functional purity:

```ts
const bannedSyntax = new Set([
  ts.SyntaxKind.ClassDeclaration,
  ts.SyntaxKind.Decorator,
  ts.SyntaxKind.ThisKeyword,
  ts.SyntaxKind.NewExpression,
  ts.SyntaxKind.HeritageClause,
  ts.SyntaxKind.MappedType,
  ts.SyntaxKind.ConditionalType,
  ts.SyntaxKind.TemplateLiteralType,
  ts.SyntaxKind.IndexSignature,
  ts.SyntaxKind.EnumDeclaration
]);
```

If we introduced a class or enum, the build would fail with diagnostics such as:

```text
GateError: LFP000x: Disallowed syntax in Iteration-1: ClassDeclaration (src/types.ts:10:1)
```

### 2. Policy Pass

Policies live under `packages/lfp-type-compiler/src/policy/rules` and enforce semantics including:

- LFP1006 – ADTs must be discriminated by `type` with unique strings.
- LFP1007 – calls to `match()` must cover every ADT case.
- LFP1008 – `interface` in schemas is forbidden.
- LFP1009 – optional properties must use `?` rather than `T | undefined`.
- LFP1015 – only canonical forms (`readonly T[]` and `T[]`, not `Array<T>`).

Our types already comply, so we see zero diagnostics.

### 3. Transform Pass

Two transformers run:

- Schema Root Rewriter (`schema-root-rewriter.ts`) finds `export type FooSchema = Foo` and emits `export const Foo$ = [...]`.
- Type Encoder (`typeOf-rewriter.ts` + `type-encoder.ts`) converts TypeScript type nodes into bytecode arrays using the `Op` enum (primitives, object, property, union, discriminated union, brand).

The compiled output appears in `dist/`. Inspect `dist/types.schema.js`:

```ts
// dist/types.schema.js
export const TaskSchema$ = [
  8, 5,
  9, "id", 0, [14, "TaskId", [0]],
  9, "name", 0, [0],
  9, "createdAt", 0, [1],
  9, "completed", 0, [2],
  9, "owner", 1, [14, "UserId", [0]]
];
export const UserSchema$ = [
  8, 3,
  9, "id", 0, [14, "UserId", [0]],
  9, "name", 0, [0],
  9, "email", 1, [0]
];
export const TaskEventSchema$ = [
  13, "type", 3,
  "created", [
    8, 1,
    9, "type", 0, [5, "created"],
    9, "task", 0, TaskSchema$
  ],
  "completed", [
    8, 3,
    9, "type", 0, [5, "completed"],
    9, "taskId", 0, [14, "TaskId", [0]],
    9, "at", 0, [1]
  ],
  "deleted", [
    8, 2,
    9, "type", 0, [5, "deleted"],
    9, "taskId", 0, [14, "TaskId", [0]]
  ]
];
```

The first few numbers map to opcodes:

- `8` is `Op.OBJECT`.
- `9` is `Op.PROPERTY`.
- `14` is `Op.BRAND`.
- `13` is `Op.DUNION`, the discriminated-union opcode recently enabled in the encoder.

For readability you can map the numbers using `packages/lfp-type-spec/src/mod.ts`; the runtime does exactly that.

## Replacing `typeOf<T>()`

Our project did not call `typeOf<T>()` directly—the schema-root pattern avoids it—yet the same transform rewrites inline `typeOf<T>()`. Example from `deno_example/src/types.ts`:

```ts
// TypeScript input
export const User$ = typeOf<User>();
```

```ts
// Compiled output
export const User$ = [
  8, 3,
  9, "id", 0, [14, "UserId", [0]],
  9, "name", 0, [0],
  9, "email", 1, [0]
];
```

No runtime `typeOf` call survives; the array literal is baked into the bundle.

## Running the Validated Program

### Prepare sample data

Populate `sample.json` with intentionally invalid data to see the validator in action:

```json
{
  "id": "u_123",
  "name": "Grace Hopper",
  "createdAt": "2025-10-28T12:00:00Z",
  "completed": false,
  "owner": "u_123"
}
```

Notice two issues:

- `createdAt` must be a number (UNIX timestamp), yet we provided a string.
- `owner` is allowed, but downstream code usually intersects IDs with branded types, so treating it as a plain string is suspicious.

### Run the program

```text
$ deno task start
error: Uncaught (in promise) Error: LFP runtime: missing bytecode. Expected compiler-inlined bytecode array.
```

That message appears when we forget to import the schema file before using the constants. Add this line to `src/main.ts` (as shown earlier):

```ts
import "./types.schema.ts";
```

Rebuild and rerun:

```text
$ deno task build
$ deno task start
Validated task { id: "t_1730123456789", name: "Grace Hopper", createdAt: 1730123456789, completed: false, owner: undefined }
Event summary Completed t_1730123456789
```

With valid data the program succeeds. Now run with the invalid `sample.json`:

```text
$ deno task start
error: Uncaught (in promise) ValidationError: createdAt: expected finite number
    at validateWith (packages/lfp-type-runtime/mod.ts:47:13)
    at validate (packages/lfp-type-runtime/mod.ts:163:3)
    at file:///.../dist/main.js:9:21
```

Removing `name` entirely produces:

```text
name: expected string, got undefined
```

Because the runtime walks the object schema and respects optional flags encoded as `0/1` in `Op.PROPERTY`, the messages stay precise.

## Result-Oriented Validation

Use `validateSafe` to get `Result<T, ValidationError>` rather than throwing:

```ts
const result = validateSafe<typeof TaskSchema$>(TaskSchema$, parsed);
if (!result.ok) {
  console.error(`Invalid Task at ${result.error.path}: ${result.error.message}`);
}
```

Console output for the bad sample becomes:

```text
Invalid Task at createdAt: createdAt: expected finite number
```

## Serialization

`serialize` currently mirrors `validate` (no transformations) but is reserved for future canonicalization:

```ts
const persisted = serialize(TaskSchema$, task);
// persisted === task
```

## Pattern Matching with ADTs

Our `match` helper relies on `Op.DUNION`. Because the encoder emits `DUNION`, runtime dispatch is `O(1)` on the tag:

```ts
const summary = match(taskEvent, {
  created: ({ task }) => `Created ${task.name}`,
  completed: ({ taskId }) => `Completed ${taskId}`,
  deleted: ({ taskId }) => `Deleted ${taskId}`
});
```

If a case is missing, the compiler (policy rule LFP1007) complains during build:

```text
PolicyError: LFP1007: non-exhaustive match over ADT (missing cases: 'deleted')
```

This is the “compile-time ADT safety + runtime validation” story in action.

## Understanding the Bytecode

The bytecode format is documented in `BYTECODE_REFERENCE.md`. Here’s a condensed table of opcodes we saw:

| Opcode   | Num | Meaning                          |
|----------|-----|----------------------------------|
| STRING   | 0   | string primitive                 |
| NUMBER   | 1   | finite number                    |
| BOOLEAN  | 2   | boolean                          |
| OBJECT   | 8   | object literal                   |
| PROPERTY | 9   | property payload                 |
| UNION    | 11  | non-discriminated union          |
| READONLY | 12  | structural readonly wrapper      |
| DUNION   | 13  | discriminated union (type)       |
| BRAND    | 14  | structural brand wrapper         |

Looking back at `TaskEventSchema$`:

```ts
[
  13, "type", 3,                 // Op.DUNION, key="type", three variants
  "created", [8, ...],           // variant 1: object literal
  "completed", [8, ...],         // variant 2
  "deleted", [8, ...]            // variant 3
]
```

Each variant is itself an object schema with properties encoded as `[Op.PROPERTY, name, optionalFlag, schema]`. Because we emit `DUNION`, runtime matching is fast: the validator reads the tag key, picks the variant, and validates once instead of walking every branch.

`TaskSchema$` shows brands:

```ts
[14, "TaskId", [0]]
```

`Op.BRAND` wraps a nested schema (in this case `[0]` → `Op.STRING`) with the string tag `TaskId`. The runtime currently validates the inner schema only but keeps the brand flag for future features such as nominal comparisons or serialization hints.

## Putting It All Together

Simulate a full run from scratch:

```text
$ cat sample.json
{
  "id": "t_1730123456789",
  "name": "CLI redesign",
  "createdAt": 1730123456789,
  "completed": false
}

$ deno task build
Task build deno run -A packages/lfp-type-compiler/src/cli.ts src --outDir dist
✨  Gate pass (syntax bans) – 0 diagnostics
✨  Policy pass (semantic rules) – 0 diagnostics
✨  Transform pass – emitted bytecode for 3 schemas

$ deno task start
Validated task {
  id: "t_1730123456789",
  name: "CLI redesign",
  createdAt: 1730123456789,
  completed: false,
  owner: undefined
}
Event summary Completed t_1730123456789

$ cat sample.json
{
  "id": "t_1730123456789",
  "name": 42,
  "createdAt": 1730123456789,
  "completed": false
}

$ deno task start
error: Uncaught (in promise) ValidationError: name: expected string, got number
```

The path-aware message makes it trivial to surface errors to API consumers.

## Why This Workflow Matters

- Zero-trust edges: Even though TypeScript erases types, LFP’s compiler-generated bytecode ensures runtime validation has the same shape guarantees as the compile-time types.
- Functional discipline: Banning classes, `this`, and mutable patterns keeps schemas and domain logic in a small, predictable surface area, simplifying future transformations (WASM validators, static analysis).
- Canonical syntax: Rules like LFP1015 (no `ReadonlyArray<T>`) eliminate stylistic drift so tooling and code reviews focus on intent rather than formatting.
- Performance: Emitting `Op.DUNION` makes ADT validation dispatch constant-time, eliminating the cost of trial-and-error union matching for large variant lists.
- Extensibility: The bytecode spec is versioned (`BYTECODE_REFERENCE.md`) and separates logical structure from encoding, paving the way for WASM runtimes without changing user code.

## Key Takeaways

- Compile-time safety: Gate + policy catch invalid syntax and semantics before any bytecode is produced.
- Functional patterns: Everything is readonly, ADTs are first-class, and brand intersections allow nominal semantics without classes.
- Runtime confidence: Validators walk explicit opcode arrays and report precise paths; `validateSafe` gives ergonomic error handling.
- Performance & portability: Discriminated unions compile to `Op.DUNION`, enabling fast tag dispatch and opening WASM backends that share the same logical spec.
- Simplicity: The workflow—write canonical TS, run `deno task build`, run `deno task start`—mirrors the architecture in `demo_cli` but applies to any LFP project.

By following this pattern you can build services that respect functional programming principles, enjoy rich compile-time feedback, and still validate every incoming byte at runtime without shipping a full type checker. Light-FP gives you expressive TypeScript for developers and trustworthy schemas for your runtime.
