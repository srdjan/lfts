# Phase 3: Enhanced Developer Experience (v0.8.0) - Implementation Plan

**Status**: ðŸ“‹ **PLANNED** (Not yet implemented)
**Estimated Effort**: 2-3 weeks
**Estimated LOC**: 2,000-3,000 new lines + tests

---

## Overview

Phase 3 adds three major developer experience enhancements while maintaining all Light-FP guarantees from Phases 1 and 2:

1. **Convention-Based Auto-Generation** - Reduce ceremony with config-driven schema generation
2. **Schema Discovery Tooling** - CLI tools and barrel exports for better discoverability
3. **Enhanced Type Encoder** - Support safe TypeScript utility types and const enums

---

## Enhancement 1: Convention-Based Auto-Generation

### Goal

Reduce ceremony for projects with many schemas while maintaining explicit control through configuration.

### Design

#### Config Schema (`lfts.config.json`)

```json
{
  "autoSchema": {
    "enabled": true,
    "include": ["src/domain/**/*.ts", "src/api/dto/**/*.ts"],
    "exclude": ["**/*.test.ts", "**/*.spec.ts"],
    "exportedOnly": true,
    "outputDir": "generated"  // Optional: separate dir for generated schemas
  },
  "rules": {
    // ... existing rules
  }
}
```

**Options:**
- `enabled`: Enable/disable auto-generation (default: `false`)
- `include`: Glob patterns for files to process
- `exclude`: Glob patterns to skip (default: test files)
- `exportedOnly`: Only generate schemas for exported types (default: `true`)
- `outputDir`: Optional directory for generated `.schema.ts` files

#### Behavior

**Input files matching pattern:**
```typescript
// src/domain/user.ts (matches include pattern)
export type User = {
  id: string;
  name: string;
  email: string;
};

export type Admin = User & {
  permissions: string[];
};

// Internal helper (not exported)
type UserCache = Map<string, User>;  // Not generated (exportedOnly: true)
```

**Auto-generated output:**
```typescript
// src/domain/user.schema.ts (auto-generated)
// DO NOT EDIT - Generated by LFTS compiler
// Source: src/domain/user.ts

export const User$ = [14, 3, 0, 4, "id", 0, [0], ...];
export const Admin$ = [14, 4, 0, 4, "id", 0, [0], ...];

// Metadata for discovery
export const __schemas = {
  User: User$,
  Admin: Admin$,
};
```

#### Implementation Plan

##### 1.1: Config Type Definitions

**File**: `packages/lfts-type-compiler/src/config.ts` (NEW)

```typescript
export type AutoSchemaConfig = {
  enabled: boolean;
  include: string[];
  exclude?: string[];
  exportedOnly?: boolean;
  outputDir?: string;
};

export type LftsConfig = {
  autoSchema?: AutoSchemaConfig;
  rules?: Record<string, any>;
};

export function readConfig(): LftsConfig {
  // Move from context.ts, add validation
}

export function validateConfig(config: LftsConfig): ValidationResult {
  // Validate glob patterns, paths, etc.
}
```

**Estimated LOC**: 150

##### 1.2: Auto-Schema Transformer

**File**: `packages/lfts-type-compiler/src/transform/auto-schema-rewriter.ts` (NEW)

```typescript
import ts from "npm:typescript";
import { glob } from "https://deno.land/std/fs/mod.ts";
import { encodeType } from "./type-encoder.ts";

export function autoSchemaRewriter(
  program: ts.Program,
  checker: ts.TypeChecker,
  config: AutoSchemaConfig,
) {
  return (ctx: ts.TransformationContext) => {
    return (sf: ts.SourceFile) => {
      // 1. Check if source file matches include/exclude patterns
      if (!shouldProcess(sf.fileName, config)) {
        return sf;
      }

      // 2. Find all exported type declarations
      const exports = findExportedTypes(sf, checker);

      // 3. Generate schema constants for each
      const schemas = exports.map(exp =>
        generateSchemaConstant(exp, checker)
      );

      // 4. Write .schema.ts file
      writeSchemaFile(sf.fileName, schemas, config);

      // Return original source unchanged
      return sf;
    };
  };
}

function shouldProcess(fileName: string, config: AutoSchemaConfig): boolean {
  // Match against include/exclude patterns
}

function findExportedTypes(
  sf: ts.SourceFile,
  checker: ts.TypeChecker,
): ts.TypeAliasDeclaration[] {
  // Walk AST, find exported type aliases
}

function generateSchemaConstant(
  decl: ts.TypeAliasDeclaration,
  checker: ts.TypeChecker,
): SchemaConstant {
  const name = decl.name.text;
  const bytecode = encodeType(decl.type, checker);
  return { name, bytecode };
}

function writeSchemaFile(
  sourceFile: string,
  schemas: SchemaConstant[],
  config: AutoSchemaConfig,
): void {
  // Generate .schema.ts file with header comment
  // Include __schemas metadata object
}
```

**Estimated LOC**: 300

##### 1.3: Integration with Compiler

**File**: `packages/lfts-type-compiler/src/compiler.ts` (MODIFY)

```typescript
import { autoSchemaRewriter } from "./transform/auto-schema-rewriter.ts";

export function compile(/* ... */) {
  const config = readConfig();

  // ... gate, policy passes

  // NEW: Auto-schema pass (runs before other transforms)
  if (config.autoSchema?.enabled) {
    const autoTransformer = autoSchemaRewriter(program, checker, config.autoSchema);
    // Run first, generates .schema.ts files
    emitFiles(program, [autoTransformer]);
  }

  // Existing transformers
  const transformers: ts.CustomTransformers = {
    before: [
      schemaRootRewriter(program, checker),
      typeOfRewriter(program, checker),
    ],
  };

  // ... continue compilation
}
```

**Estimated LOC**: 50 (modifications)

##### 1.4: Tests

**File**: `packages/lfts-type-compiler/src/testing/fixtures/ok_auto_schema/` (NEW)

Test scenarios:
- Basic auto-generation with include pattern
- Exclude patterns working
- `exportedOnly: true` skips internal types
- Multiple files in directory
- Nested directories
- Generated files have correct imports
- Metadata object included

**Estimated LOC**: 400 (test files + test.json)

**Total Enhancement 1**: ~900 LOC

---

## Enhancement 2: Schema Discovery Tooling

### Goal

Make it easy to discover available schemas, generate barrel exports, and integrate with IDEs.

### Features

1. `lfts list-schemas` - List all schemas in project
2. `lfts find-schema <name>` - Find specific schema
3. `lfts generate-index` - Create barrel export files
4. `lfts watch` - Watch mode for development

### Implementation Plan

##### 2.1: CLI Framework

**File**: `packages/lfts-cli/mod.ts` (NEW PACKAGE)

```typescript
import { parseArgs } from "https://deno.land/std/cli/mod.ts";

const commands = {
  "list-schemas": listSchemasCommand,
  "find-schema": findSchemaCommand,
  "generate-index": generateIndexCommand,
  "watch": watchCommand,
};

async function main() {
  const args = parseArgs(Deno.args);
  const command = args._[0] as string;

  if (!command || !commands[command]) {
    printUsage();
    Deno.exit(1);
  }

  await commands[command](args);
}

if (import.meta.main) {
  main();
}
```

**Estimated LOC**: 100

##### 2.2: List Schemas Command

**File**: `packages/lfts-cli/commands/list-schemas.ts` (NEW)

```typescript
export async function listSchemasCommand(args: Args) {
  // 1. Find all .schema.ts files
  const schemaFiles = await glob("**/*.schema.ts", {
    ignore: ["node_modules/**", "**/testing/**"],
  });

  // 2. Parse each file to extract schema constants
  const schemas = await Promise.all(
    schemaFiles.map(file => extractSchemas(file))
  );

  // 3. Group by directory
  const grouped = groupByDirectory(schemas.flat());

  // 4. Print formatted output
  console.log("Available Schemas:\n");
  for (const [dir, items] of Object.entries(grouped)) {
    console.log(`  ${dir}/`);
    for (const schema of items) {
      console.log(`    - ${schema.name}$ (from ${schema.source})`);
    }
    console.log();
  }

  // 5. Summary
  console.log(`Total: ${schemas.flat().length} schemas in ${schemaFiles.length} files`);
}

async function extractSchemas(file: string): Promise<SchemaInfo[]> {
  // Parse file, extract exported constants ending in $
  // Also extract __schemas metadata if present
}
```

**Estimated LOC**: 200

##### 2.3: Find Schema Command

**File**: `packages/lfts-cli/commands/find-schema.ts` (NEW)

```typescript
export async function findSchemaCommand(args: Args) {
  const searchName = args._[1] as string;

  if (!searchName) {
    console.error("Usage: lfts find-schema <name>");
    Deno.exit(1);
  }

  // 1. Search for schema by name (fuzzy match)
  const matches = await searchSchemas(searchName);

  if (matches.length === 0) {
    console.log(`No schemas found matching "${searchName}"`);
    return;
  }

  // 2. Display results
  console.log(`Found ${matches.length} match(es):\n`);
  for (const match of matches) {
    console.log(`  ${match.name}$`);
    console.log(`    File: ${match.file}`);
    console.log(`    Source: ${match.sourceType}`);
    console.log(`    Import: import { ${match.name}$ } from "${match.importPath}"`);
    console.log();
  }
}

async function searchSchemas(name: string): Promise<SchemaInfo[]> {
  // Fuzzy search across all schema files
  // Support partial matches (e.g., "User" finds "User$", "UserInput$", etc.)
}
```

**Estimated LOC**: 150

##### 2.4: Generate Index Command

**File**: `packages/lfts-cli/commands/generate-index.ts` (NEW)

```typescript
export async function generateIndexCommand(args: Args) {
  const targetDir = args.dir || ".";

  // 1. Find all .schema.ts files in target directory (not recursive by default)
  const schemaFiles = await glob(`${targetDir}/*.schema.ts`);

  if (schemaFiles.length === 0) {
    console.log(`No .schema.ts files found in ${targetDir}`);
    return;
  }

  // 2. Extract exports from each file
  const exports = await Promise.all(
    schemaFiles.map(file => extractExports(file))
  );

  // 3. Generate index.schema.ts
  const indexPath = `${targetDir}/index.schema.ts`;
  const content = generateIndexFile(exports.flat());

  await Deno.writeTextFile(indexPath, content);

  console.log(`âœ“ Generated ${indexPath}`);
  console.log(`  Exported ${exports.flat().length} schemas`);
}

function generateIndexFile(exports: Export[]): string {
  const lines = [
    "// Auto-generated barrel export",
    "// DO NOT EDIT",
    "",
  ];

  for (const exp of exports) {
    lines.push(`export { ${exp.names.join(", ")} } from "./${exp.file}";`);
  }

  return lines.join("\n") + "\n";
}
```

**Estimated LOC**: 150

##### 2.5: Watch Mode

**File**: `packages/lfts-cli/commands/watch.ts` (NEW)

```typescript
import { watch } from "https://deno.land/std/fs/mod.ts";

export async function watchCommand(args: Args) {
  console.log("Watching for changes...\n");

  const watcher = watch(".", { recursive: true });

  for await (const event of watcher) {
    if (event.kind === "modify" && event.paths.some(p => p.endsWith(".ts"))) {
      console.log(`\n[${new Date().toLocaleTimeString()}] Detected change: ${event.paths[0]}`);

      // Recompile
      try {
        await compileProject();
        console.log("âœ“ Compilation successful");
      } catch (err) {
        console.error("âœ— Compilation failed:", err.message);
      }
    }
  }
}
```

**Estimated LOC**: 100

##### 2.6: deno.json Task Integration

**File**: Update root `deno.json`

```json
{
  "tasks": {
    "lfts": "deno run -A packages/lfts-cli/mod.ts",
    "lfts:list": "deno task lfts list-schemas",
    "lfts:watch": "deno task lfts watch"
  }
}
```

**Total Enhancement 2**: ~700 LOC

---

## Enhancement 3: Enhanced Type Encoder

### Goal

Support safe TypeScript utility types and const enums while maintaining Light-FP subset restrictions.

### Features

1. **Built-in Utility Types**: `Partial<T>`, `Required<T>`, `Readonly<T>`, `Pick<T, K>`, `Omit<T, K>`
2. **Const Enums**: Expand to literal unions
3. **More Annotations**: `NonEmpty<T>`, `Positive`, `Negative`, `Integer`, `Port<T>`

### Implementation Plan

##### 3.1: Utility Type Support

**File**: `packages/lfts-type-compiler/src/transform/type-encoder.ts` (MODIFY)

```typescript
export function encodeType(node: ts.TypeNode, checker: ts.TypeChecker): Bytecode {
  // Existing handling...

  // NEW: Handle utility types
  if (ts.isTypeReferenceNode(node)) {
    const typeName = node.typeName.getText();

    // Built-in utility types
    if (typeName === "Partial" && node.typeArguments?.length === 1) {
      return encodePartial(node.typeArguments[0], checker);
    }

    if (typeName === "Required" && node.typeArguments?.length === 1) {
      return encodeRequired(node.typeArguments[0], checker);
    }

    if (typeName === "Pick" && node.typeArguments?.length === 2) {
      return encodePick(node.typeArguments[0], node.typeArguments[1], checker);
    }

    if (typeName === "Omit" && node.typeArguments?.length === 2) {
      return encodeOmit(node.typeArguments[0], node.typeArguments[1], checker);
    }

    // Readonly<T> - already handled, but ensure consistent
    if (typeName === "Readonly" && node.typeArguments?.length === 1) {
      const inner = encodeType(node.typeArguments[0], checker);
      return [Op.READONLY, inner];
    }
  }

  // ... rest of encoding
}

function encodePartial(typeArg: ts.TypeNode, checker: ts.TypeChecker): Bytecode {
  // 1. Resolve typeArg to get object type
  const innerType = checker.getTypeFromTypeNode(typeArg);

  // 2. If not an object type, error
  if (!innerType.isClassOrInterface() && !(innerType.flags & ts.TypeFlags.Object)) {
    throw new EncodingError("Partial<T> requires T to be an object type");
  }

  // 3. Encode as object with all properties optional
  const symbol = innerType.getSymbol();
  if (!symbol) throw new EncodingError("Cannot get symbol for Partial type");

  const props = checker.getPropertiesOfType(innerType);
  const encoded = [Op.OBJECT, props.length, 0];  // strict = false

  for (const prop of props) {
    const propType = checker.getTypeOfSymbolAtLocation(prop, typeArg);
    const propTypeNode = checker.typeToTypeNode(propType, undefined, undefined);
    if (!propTypeNode) throw new EncodingError(`Cannot encode property ${prop.name}`);

    encoded.push(
      Op.PROPERTY,
      prop.name,
      1,  // optional = true (Partial makes all props optional)
      encodeType(propTypeNode, checker),
    );
  }

  return encoded;
}

function encodeRequired(typeArg: ts.TypeNode, checker: ts.TypeChecker): Bytecode {
  // Similar to Partial, but optional = false for all props
}

function encodePick(
  typeArg: ts.TypeNode,
  keysArg: ts.TypeNode,
  checker: ts.TypeChecker,
): Bytecode {
  // 1. Resolve typeArg to object type
  // 2. Extract keys from keysArg (must be union of string literals)
  // 3. Encode object with only specified keys
}

function encodeOmit(
  typeArg: ts.TypeNode,
  keysArg: ts.TypeNode,
  checker: ts.TypeChecker,
): Bytecode {
  // 1. Resolve typeArg to object type
  // 2. Extract keys from keysArg
  // 3. Encode object with all keys EXCEPT specified ones
}
```

**Estimated LOC**: 400 (modifications + new functions)

##### 3.2: Const Enum Support

**File**: `packages/lfts-type-compiler/src/transform/type-encoder.ts` (MODIFY)

```typescript
export function encodeType(node: ts.TypeNode, checker: ts.TypeChecker): Bytecode {
  // ... existing

  // NEW: Handle const enum references
  if (ts.isTypeReferenceNode(node)) {
    const symbol = checker.getSymbolAtLocation(node.typeName);

    if (symbol && symbol.flags & ts.SymbolFlags.ConstEnum) {
      // Get enum members
      const members = checker.getTypeOfSymbolAtLocation(symbol, node).types;

      // Encode as union of literals
      const alternatives = members.map(member => {
        const value = member.value;  // Get literal value
        return [Op.LITERAL, value];
      });

      return [Op.UNION, alternatives.length, ...alternatives.flat()];
    }
  }

  // ...
}
```

**Gate Pass Update**: Remove const enum restriction

**File**: `packages/lfts-type-compiler/src/gate/gate.ts` (MODIFY)

```typescript
function visit(node: ts.Node) {
  // REMOVE: Rejection of const enums
  // NOW ALLOWED:
  if (ts.isEnumDeclaration(node) && hasModifier(node, ts.SyntaxKind.ConstKeyword)) {
    // Const enums are now supported
    return;
  }

  // Still reject non-const enums
  if (ts.isEnumDeclaration(node)) {
    report(node, "LFG1004: Regular enums not allowed. Use const enum or union of literals.");
  }

  // ...
}
```

**Estimated LOC**: 150 (modifications)

##### 3.3: Additional Annotations

**File**: `packages/lfts-type-runtime/annotations.ts` (NEW)

```typescript
// Additional prebuilt annotation types

/** Array must have at least one element */
export type NonEmpty<T extends any[]> = T;

/** Number must be positive (> 0) */
export type Positive = number;

/** Number must be negative (< 0) */
export type Negative = number;

/** Number must be an integer */
export type Integer = number;

/** Port marker for dependency injection */
export type Port<T> = T;

// Implementation note: These are recognized by type encoder
// and compiled to refinement opcodes
```

**File**: `packages/lfts-type-spec/src/mod.ts` (MODIFY)

Add new refinement opcodes:

```typescript
export enum Op {
  // ... existing

  // NEW refinements
  REFINE_NON_EMPTY = 50,   // Array must have at least 1 element
  REFINE_POSITIVE = 51,    // Number > 0
  REFINE_NEGATIVE = 52,    // Number < 0
}
```

**File**: `packages/lfts-type-compiler/src/transform/type-encoder.ts` (MODIFY)

```typescript
function detectAnnotation(typeName: string, checker: ts.TypeChecker): Op | null {
  // Existing: Email, Url, Min<N>, Max<N>, etc.

  // NEW annotations:
  if (typeName === "NonEmpty") return Op.REFINE_NON_EMPTY;
  if (typeName === "Positive") return Op.REFINE_POSITIVE;
  if (typeName === "Negative") return Op.REFINE_NEGATIVE;
  if (typeName === "Integer") return Op.REFINE_INTEGER;  // Already exists

  return null;
}
```

**File**: `packages/lfts-type-runtime/mod.ts` (MODIFY)

Add validation for new refinements:

```typescript
function validateWith(schema: TypeObject, value: unknown, path: Path): VResult {
  const op = schema[0];

  switch (op) {
    // ... existing

    case Op.REFINE_NON_EMPTY: {
      const [_, inner] = schema;
      const result = validateWith(inner, value, path);
      if (!result.ok) return result;

      if (Array.isArray(value) && value.length === 0) {
        return err("array must not be empty", path);
      }
      return ok();
    }

    case Op.REFINE_POSITIVE: {
      if (typeof value !== "number" || value <= 0) {
        return err("expected positive number", path);
      }
      return ok();
    }

    case Op.REFINE_NEGATIVE: {
      if (typeof value !== "number" || value >= 0) {
        return err("expected negative number", path);
      }
      return ok();
    }
  }
}
```

**Estimated LOC**: 200 (new file + modifications)

##### 3.4: Tests for Enhanced Encoder

**Test Scenarios**:
- `Partial<User>` - all props optional
- `Required<PartialUser>` - remove optionality
- `Pick<User, "id" | "name">` - subset of props
- `Omit<User, "password">` - exclude props
- Const enum â†’ literal union
- New annotations (NonEmpty, Positive, etc.)
- Error cases (invalid utility type args)

**Estimated LOC**: 500 (test files)

**Total Enhancement 3**: ~1,250 LOC

---

## Testing Strategy

### Unit Tests

Each enhancement should have:
- Positive tests (feature works)
- Negative tests (proper errors)
- Edge cases
- Integration with existing features

### Golden Tests

Add new fixtures to `packages/lfts-type-compiler/src/testing/fixtures/`:
- `ok_utility_types/` - Partial, Required, Pick, Omit
- `ok_const_enum/` - Const enum expansion
- `ok_annotations_extended/` - NonEmpty, Positive, etc.
- `ok_auto_schema/` - Convention-based generation
- `fail_invalid_utility_args/` - Wrong args to utility types

### Integration Tests

- End-to-end: Define type with utility types â†’ compile â†’ validate at runtime
- CLI: Run each command, verify output
- Auto-generation: Create project with config â†’ verify generated files

---

## Documentation Updates

### New Documents

1. **docs/AUTO_SCHEMA.md** - Convention-based generation guide
2. **docs/CLI_REFERENCE.md** - Complete CLI command reference
3. **docs/UTILITY_TYPES.md** - Supported utility types and examples

### Updated Documents

1. **CLAUDE.md** - Add Phase 3 features
2. **docs/SCHEMA_GENERATION.md** - Add auto-schema section
3. **docs/FEATURES.md** - Update with v0.8.0 features
4. **README.md** - Update feature list
5. **docs/LANG-SPEC.md** - Add const enum, utility types to spec

---

## Migration Guide (v0.7.0 â†’ v0.8.0)

### No Breaking Changes

Phase 3 is **purely additive** - all existing code continues to work.

### New Features Available

#### 1. Opt Into Auto-Schema

```json
// lfts.config.json
{
  "autoSchema": {
    "enabled": true,
    "include": ["src/domain/**/*.ts"]
  }
}
```

Now your domain types automatically get schemas!

#### 2. Use CLI Tools

```bash
# List all schemas
deno task lfts:list

# Find specific schema
deno task lfts find-schema User

# Generate barrel exports
deno task lfts generate-index --dir src/domain
```

#### 3. Use Utility Types

```typescript
// Before: Manual partial type
type UpdateUserInput = {
  id: string;
  name?: string;
  email?: string;
};

// After: Use Partial
type UpdateUserInput = { id: string } & Partial<Pick<User, "name" | "email">>;
export type UpdateUserInputSchema = UpdateUserInput;
```

---

## Release Checklist

- [ ] All enhancements implemented
- [ ] All tests passing (including new tests)
- [ ] Documentation complete
- [ ] Examples updated
- [ ] Migration guide written
- [ ] CHANGELOG.md updated
- [ ] Version bumped to v0.8.0
- [ ] Release notes prepared

---

## Estimated Timeline

- **Week 1**: Enhancement 1 (Auto-Schema) + tests
- **Week 2**: Enhancement 2 (CLI Tools) + Enhancement 3 (Type Encoder) + tests
- **Week 3**: Documentation, polish, release prep

---

## Open Questions

1. **Auto-Schema**: Should generated files be committed to git or gitignored?
   - **Pro commit**: Explicit, reviewable, no build step for users
   - **Pro gitignore**: Cleaner diffs, obvious they're generated
   - **Recommendation**: Commit by default, document gitignore option

2. **CLI Package**: Separate package or integrated?
   - **Separate**: `packages/lfts-cli` (cleaner)
   - **Integrated**: Part of `lfts-type-compiler` (simpler)
   - **Recommendation**: Separate package, cleaner separation

3. **Utility Types**: How far to go?
   - Just the safe ones? (Partial, Required, Pick, Omit, Readonly)
   - Or more advanced? (Record, ReturnType, Parameters, etc.)
   - **Recommendation**: Start with safe ones, add others if requested

4. **Watch Mode**: Should it trigger on any .ts or only .schema.ts?
   - **Any .ts**: More responsive, but more rebuilds
   - **Only .schema.ts**: Less churn, but may miss changes
   - **Recommendation**: Any .ts in src/, with debouncing

---

## Success Metrics

Phase 3 is successful if:

1. âœ… **Convention-based generation works** for projects with 50+ schemas
2. âœ… **CLI tools are intuitive** and provide value
3. âœ… **Utility types reduce boilerplate** by 30-50%
4. âœ… **All Light-FP guarantees maintained** (subset, ports discipline, bundle size)
5. âœ… **No breaking changes** - smooth upgrade from v0.7.0
6. âœ… **Documentation is comprehensive** - users can adopt features easily

---

## Implementation Priority

If implementing incrementally:

**Priority 1 (High Value, Low Risk)**:
- Enhancement 3.3: Additional annotations (NonEmpty, Positive, etc.)
- Enhancement 2.1-2.3: Basic CLI (list-schemas, find-schema)

**Priority 2 (High Value, Medium Risk)**:
- Enhancement 3.1-3.2: Utility types and const enums
- Enhancement 2.4: Generate index files

**Priority 3 (Nice to Have)**:
- Enhancement 1: Auto-schema (complex, needs careful design)
- Enhancement 2.5: Watch mode

**Rationale**: Start with smaller, contained features that provide immediate value. Auto-schema is most complex and should be last to ensure design is correct.

---

## Conclusion

Phase 3 represents a significant step forward in developer experience while maintaining Light-FP's core principles:

- âœ… **Subset enforcement preserved** (utility types are safe, const enums are expanded)
- âœ… **Explicitness maintained** (auto-schema is config-driven, CLI makes schemas discoverable)
- âœ… **Bundle size controlled** (utility types compile away, const enums are inlined)
- âœ… **No decorators** (all features work with plain TypeScript)

This plan provides a complete roadmap for Phase 3 implementation. Each enhancement is designed to be **independently deliverable** and **incrementally adoptable**.

**Next Steps**: Review plan â†’ prioritize features â†’ begin implementation of Priority 1 items.
